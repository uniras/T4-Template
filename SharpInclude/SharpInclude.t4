<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#+
    //SharpInlucde用の定義
    class SharpIncludeDefines
    {
        public static string SharpIncludeStartDelim = @"//<(\+\++|--+)";
        public static string SharpIncludeEndDelim = @"//(\+\++|--+)>";

        public static string StartDelim = "<" + "#";
        public static string EndDelim = "#" + ">";
        public static string StartFeatureDelim = StartDelim + "+";
        public static string EndFeatureDelim = EndDelim;
    }

    string SharpInclude()
    {
        return SharpInclude(Host.TemplateFile);
    }

    /*
        ファイルで指定したブロック全てを機能ブロックまたはコントロールブロックとして取り込みます。
    */
    string SharpInclude(string file)
    {
        return SharpInclude(file, -1);
    }

    /*
        ファイルで指定したブロックのうちの(pos+1)番目のブロックを機能ブロックまたはコントロールブロックとして取り込みます。
    */
    string SharpInclude(string file, int pos)
    {
        return SharpIncludeFile(file, pos, true, false);
    }

    /*
        usingを解析するかどうかを指定し、ファイルで指定したブロック全てを機能ブロックまたはコントロールブロックとして取り込みます。
    */
    string SharpInclude(string file, bool inusing)
    {
        return SharpInclude(file, -1, inusing);
    }

    /*
        usingを解析するかどうか指定し、ファイルで指定したブロックのうちの(pos+1)番目のブロックを機能ブロックまたはコントロールブロックとして取り込みます。
    */
    string SharpInclude(string file, int pos, bool inusing)
    {
        return SharpIncludeFile(file, pos, inusing, false);
    }

    /*
        複数のファイルでそれぞれ指定したブロック全てを機能ブロックまたはコントロールブロックとして取り込みます。
    */
    string SharpIncludeList(params string[] files)
    {
        StringBuilder UsingSource = new StringBuilder();
        StringBuilder BlockSource = new StringBuilder();

        System.Environment.CurrentDirectory = Path.GetDirectoryName(Host.TemplateFile);
        for (int i = 0; i < files.Length; i++)
        {
            string src = File.ReadAllText(files[i]);
            UsingSource.Append(SharpIncludeGetUsingString(src) + Environment.NewLine);
            BlockSource.Append(src);
        }

        return UsingSource.ToString() + Environment.NewLine +
               SharpIncludeFile(BlockSource.ToString(), -1, false, false);
    }

    /*
        ファイルで指定したブロック全てをそのまま取り込みます。
    */
    string SharpMixin(string file)
    {
        return SharpMixin(file, -1);
    }

    /*
        ファイルで指定したブロックのうちの(pos+1)番目のブロックをそのまま取り込みます。
    */
    string SharpMixin(string file, int pos)
    {
        return SharpIncludeFile(file, pos, false, true);
    }

    /*
        複数のファイルでそれぞれ指定したブロック全てをそのまま取り込みます。
    */
    string SharpMixinList(params string[] files)
    {
        StringBuilder BlockSource = new StringBuilder();
        for (int i = 0; i < files.Length; i++)
        {
            BlockSource.Append(SharpIncludeFile(files[i], -1, false, true));
        }
        return BlockSource.ToString();
    }

    string SharpIncludeFile(string file, int pos, bool inusing, bool mixin)
    {
        return SharpIncludeString(SharpIncludeReadFile(file), pos, inusing, mixin);
    }

    string SharpIncludeString(string src, int pos, bool inusing, bool mixin)
    {
        StringBuilder ret = new StringBuilder();
        StringBuilder fblock = new StringBuilder();
        StringBuilder cblock = new StringBuilder();

        int cnt = 0;
        Regex regex = new Regex(SharpIncludeDefines.SharpIncludeStartDelim + @"[\r\n]*([\s\S]*?)\s*?" + SharpIncludeDefines.SharpIncludeEndDelim);
        Match match = regex.Match(src);
        while (match.Success)
        {
            if (pos < 0 || pos == cnt)
            {
                Group grp = match.Groups[2];
                if (!mixin)
                {
                    Match blank = Regex.Match(grp.ToString(), @"^\s+$");
                    if (grp.Length > 0 && !blank.Success)
                    {
                        Group type = match.Groups[1];
                        if(type.ToString()[0] == '+')
                        {
                            fblock.Append(grp);
                        }
                        else
                        {
                            cblock.Append(grp);
                        }
                    }
                }
                else
                {
                    ret.Append(grp);
                }
            }
            cnt++;
            match = match.NextMatch();
        }

        if (!mixin)
        {
            if(fblock.Length > 0)
            {
                ret.Insert(0, SharpIncludeDefines.StartFeatureDelim + Environment.NewLine);
                ret.Append(fblock.ToString());
                ret.Append(Environment.NewLine + SharpIncludeDefines.EndFeatureDelim);
            }
            if(cblock.Length > 0)
            {
                ret.Insert(0, Environment.NewLine + SharpIncludeDefines.EndDelim);
                ret.Insert(0, cblock.ToString());
                ret.Insert(0, SharpIncludeDefines.StartDelim + Environment.NewLine);
            }
        }

        if (inusing)
        {
            ret.Insert(0, SharpIncludeGetUsingString(src) + Environment.NewLine);
        }

        return ret.ToString();
    }

    string SharpIncludeGetUsingString(string src)
    {
        StringBuilder ret = new StringBuilder();
        bool init = true;
        Regex regex = new Regex(@"[ \t]*using[ \t]+([_a-zA-z][_a-zA-Z0-9\.]*);");
        Match match = regex.Match(src);
        while (match.Success)
        {
            Group grp = match.Groups[1];
            if (init)
            {
                init = false;
            }
            else
            {
                ret.Append(Environment.NewLine);
            }
            ret.Append(SharpIncludeDefines.StartDelim + "@ import namespace=\"" + grp + "\" " + SharpIncludeDefines.EndDelim);
            match = match.NextMatch();
        }
        return ret.ToString();
    }

    string SharpIncludeGetUsingFile(string file)
    {
        return SharpIncludeGetUsingString(SharpIncludeReadFile(file));
    }

    string SharpIncludeReadFile(string file)
    {
        System.Environment.CurrentDirectory = Path.GetDirectoryName(Host.TemplateFile);
        return File.ReadAllText(file);
    }
#>